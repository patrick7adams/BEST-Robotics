#pragma config(UART_Usage, UART1, uartUserControl, baudRate1200, IOPins, None, None)
#pragma config(Motor,  port2,           motorR,    tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port4,           servoB, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           servoA, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           motorA,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           motorL,     tmotorVex393_MC29, openLoop, driveLeft)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// custom baud rate set code
typedef unsigned long uint32_t;
typedef unsigned short uint16_t;
typedef struct {
	uint16_t SR;
	uint16_t RESERVED0;
	uint16_t DR;
	uint16_t RESERVED1;
	uint16_t BRR;
	uint16_t RESERVED2;
	uint16_t CR1;
	uint16_t RESERVED3;
	uint16_t CR2;
	uint16_t RESERVED4;
	uint16_t CR3;
	uint16_t RESERVED5;
	uint16_t GTPR;
	uint16_t RESERVED6;
} USART_TypeDef;

/* Peripheral memory map */
#define PERIPH_BASE ((unsigned long)0x40000000)
#define APB1PERIPH_BASE PERIPH_BASE
#define USART2_BASE (APB1PERIPH_BASE + 0x4400)
#define USART3_BASE (APB1PERIPH_BASE + 0x4800)
#define USART2 ((USART_TypeDef *) USART2_BASE)
#define USART3 ((USART_TypeDef *) USART3_BASE)



void setBaud( const TUARTs nPort, int baudRate ) {
	uint32_t tmpreg = 0x00, apbclock = 0x00;
	uint32_t integerdivider = 0x00;
	uint32_t fractionaldivider = 0x00;

	/* pclk1 - 36MHz */
	apbclock = 36000000;

	/* Determine the integer part */
	integerdivider = ((0x19 * apbclock) / (0x04 * (baudRate)));
	tmpreg = (integerdivider / 0x64) << 0x04;

	/* Determine the fractional part */
	fractionaldivider = integerdivider - (0x64 * (tmpreg >> 0x04));
	tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) & 0x0F;

	/* Write to USART BRR */
	USART_TypeDef *uart = USART2;
	if( nPort == UART2 ) {
		uart = USART3;
	}
	uart->BRR = (uint16_t)tmpreg;
}

float moveMult = 0.3; // Movement speed multiplier.
int moveLowerBound = 20; // Movement sensitivity.
float armMult = 0.3; // Arm speed multiplier.
int armLowerBound = 40; // Arm sensitivity.
int moveMode = 1; // Movement setting; tank movement is 1, arcade movement is 2.
int armState = 2; // Field robot center lever states for IR; 1 is rotate, 2 is drive, 3 is lift.
short ch = 0xAA; // IR character storage.



task IR { // sends an IR code corresponding to the button pressed.
	if(vexRT[Btn7L]) { // Sets field robot center lever to rotate.
		ch = 0x33;
		armState = 1;
  } else if (vexRT[Btn7U]) { // Sets field robot center lever to drive.
  	ch = 0x66;
  	armState = 2;
  } else if (vexRT[Btn7R]) { // Sets field robot center lever to lift.
  	ch = 0x55;
  	armState = 3;
  } else if (vexRT[Btn8L]) { // Sets field robot speed to low.
  	if(armState == 1) {
  		ch = 0x69;
  	} else if (armState == 2) {
  		ch = 0x99;
  	}
  } else if (vexRT[Btn8R]) { // Sets field robot speed to high.
  	if(armState == 1) {
  		ch = 0x0F;
  	} else if (armState == 3) {
  		ch = 0xC3;
  	}
  }
	sendChar(UART1, ch);
} // end task

task move { // Movement of the robot itself.
	if(vexRT[Btn6U]) { // toggle between arcade and tank controls
		if(moveMode == 1) {
			moveMode = 2;
		} else {
			moveMode = 1;
		}
		wait1Msec(500);
	}
	if(moveMode == 1) { // tank controls
		if(abs(vexRT[Ch3]) > moveLowerBound) {
			motor[motorL] = vexRT[Ch3]*moveMult;
		} else {
			motor[motorL] = 0;
		}
		if(abs(vexRT[Ch2]) > moveLowerBound) {
			motor[motorR] = vexRT[Ch2]*moveMult;
		} else {
			motor[motorR] = 0;
		}
	} else { // arcade controls
		if(abs(vexRT[Ch2]-vexRT[Ch1]) > moveLowerBound) {
			motor[motorL] = (vexRT[Ch2]-vexRT[Ch1])*moveMult;
		} else {
			motor[motorL] = 0;
		}
		if(abs(vexRT[Ch2]+vexRT[Ch1]) > moveLowerBound) {
			motor[motorR] = (vexRT[Ch2]+vexRT[Ch1])*moveMult;
		} else {
			motor[motorR] = 0;
		}
	} // end if
} // end task

task servoSweep { // Pushes the arm servos whenever they are pressed.
	if(vexRT[Btn5U]) {
		motor[servoA] = 64;
		motor[servoB] = 64;
	} else {
		motor[servoB] = -64;
		motor[servoA] = -64;
	}
} // end task

task arm { // Arm movement.
	if(moveMode == 2) { // Uses joystick if the robot is in arcade mode.
		if(abs(vexRT[Ch3]) > armLowerBound) {
			motor[motorA] = vexRT[Ch3] * armMult;
		} else {
			motor[motorA] = 0;
		}
	} else { // Uses buttons if the robot is in tank mode.
		if(vexRT[Btn8U]) {
			motor[motorA] = 127 * armMult;
		} else if (vexRT[Btn8D]) {
			motor[motorA] = -127 * armMult;
		} else {
			motor[motorA] = 0;
		}
	}// end if
} // end task

task main { // Runs all the tasks above.
	setBaud(UART1, 600); // Sets the infared rate of the IR transmitter.
	while (true) {
	  startTask(move);
		startTask(IR);
		startTask(servoSweep);
		startTask(arm);
	}
} // end main
