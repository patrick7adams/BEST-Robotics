#pragma config(UART_Usage, UART1, uartUserControl, baudRate1200, IOPins, None, None)
#pragma config(Motor,  port2,           rightMotor,    tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port5,           sweepServo,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           armMotor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           leftMotor,     tmotorVex393_MC29, openLoop, driveLeft)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// custom baud rate set code
typedef unsigned long uint32_t;
typedef unsigned short uint16_t;
typedef struct
{
	uint16_t SR;
	uint16_t RESERVED0;
	uint16_t DR;
	uint16_t RESERVED1;
	uint16_t BRR;
	uint16_t RESERVED2;
	uint16_t CR1;
	uint16_t RESERVED3;
	uint16_t CR2;
	uint16_t RESERVED4;
	uint16_t CR3;
	uint16_t RESERVED5;
	uint16_t GTPR;
	uint16_t RESERVED6;
} USART_TypeDef;

/* Peripheral memory map */
#define PERIPH_BASE ((unsigned long)0x40000000)
#define APB1PERIPH_BASE PERIPH_BASE
#define USART2_BASE (APB1PERIPH_BASE + 0x4400)
#define USART3_BASE (APB1PERIPH_BASE + 0x4800)
#define USART2 ((USART_TypeDef *) USART2_BASE)
#define USART3 ((USART_TypeDef *) USART3_BASE)



void setBaud( const TUARTs nPort, int baudRate ) {
	uint32_t tmpreg = 0x00, apbclock = 0x00;
	uint32_t integerdivider = 0x00;
	uint32_t fractionaldivider = 0x00;

	/* pclk1 - 36MHz */
	apbclock = 36000000;

	/* Determine the integer part */
	integerdivider = ((0x19 * apbclock) / (0x04 * (baudRate)));
	tmpreg = (integerdivider / 0x64) << 0x04;

	/* Determine the fractional part */
	fractionaldivider = integerdivider - (0x64 * (tmpreg >> 0x04));
	tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) & 0x0F;

	/* Write to USART BRR */
	USART_TypeDef *uart = USART2;
	if( nPort == UART2 ) {
		uart = USART3;
	}
	uart->BRR = (uint16_t)tmpreg;
}



int armState = 2;
short ch = 0xAA;

task IR {
	if(vexRT[Btn7L]) {
		ch = 0x33;
		armState = 1;
  } else if (vexRT[Btn7U]) {
  	ch = 0x66;
  	armState = 2;
  } else if (vexRT[Btn7R]) {
  	ch = 0x55;
  	armState = 3;
  } else if (vexRT[Btn8L]) {
  	if(armState == 1) {
  		ch = 0x69;
  	} else if (armState == 2) {
  		ch = 0x99;
  	}
  } else if (vexRT[Btn8R]) {
  	if(armState == 1) {
  		ch = 0x0F;
  	} else if (armState == 3) {
  		ch = 0xC3;
  	}
  }
	sendChar(UART1, ch);
}

task move {
	if(abs(vexRT[Ch3]) > 20) {
		motor[leftMotor] = vexRT[Ch3]/3;
	} else {
		motor[leftMotor] = 0;
	}
	if(abs(vexRT[Ch1]) > 20) {
		motor[rightMotor] = (vexRT[Ch2]+vexRT[Ch1])/3;
	} else {
		motor[rightMotor] = 0;
	}
	if(vexRT[Btn8U]) {
		motor[rightMotor] = 20;
		motor[leftMotor] = 20;
	} else if (vexRT[Btn8D]) {
		motor[rightMotor] = -20;
		motor[leftMotor] = -20;
	}
}

task servoSweep {
	if(vexRT[Btn5U]) {
		motor[sweepServo] = -64;
	} else {
		motor[sweepServo] = 64;
	}
}

task arm {
	if(abs(vexRT[Ch3]) > 40) {
		motor[armMotor] = vexRT[Ch3];
	} else {
		motor[armMotor] = 0;
	}
}

task main {
	setBaud(UART1, 600);
	while (true) {
	  startTask(move);
		startTask(IR);
		startTask(servoSweep);
		startTask(arm);
	}
}
